    wzorce kreacyjne:
        Budowniczy (obiektowy) - tworzenie etapami jednego obiektu ( wygodniejsze niż konstruktor), wewnętrzna statyczna klasa
        Fabryka abstrakcyjna (obiektowy) - kilka fabryk za jednym interfejsem tworzące całe rodziny obiektów po wspólnym typie
        Metoda wytwórcza (klasowy) - obiekt wytwarza pomocniczy obiekt. Rozdzielono abstrakcje od konkretów w ramach hierarchi dziedziczenia
        Prototyp (obiektowy) - tworzy kopię obiektu. metoda clone z Object robi powierzchowną kopię (te same referencje), czasem potrzebujemy głębszej
        Singleton (obiektowy) - max 1 obiekt danej klasy, dostępny publicznie. statyczny dostęp. lazy (uwaga na wielowątkowość), eager.

    wzorce strukturalne:
    Na zasadzie wrappera: udaje obiekt przez wspólny interfejs + zawiera obiekt i odsyła do jego działania:
        Adapter (klasowy oraz obiektowy) - gdy chcemy dopasować nasz obiekt do istniejącego interfejsu bez modyfikowania obiektu
        Dekorator (obiektowy) - rozszerzanie działania obiektu, alternatywa dla dziedziczenia, wykorzystuje kompozycje, składanie w trakcie działania aplikacji
        Pełnomocnik/proxy (obiektowy) - opakowywanie obiektu mające na celu wykonanie dodatkowej pomocniczej pracy - cashowanie, walidacja, statystyki itd.
        Kompozyt (obiektowy) - wspólny interfejs dla złożonych obiektów i pojedycznych - dla wygody klienta. np. foldery i pliki
        Most (obiektowy) - rozdzielenie abstrakcji od konkretnych implementacji na poziomie struktury. Shape ma Color. Tank ma Gun. Figure ma Behavior
        Fasada (obiektowy) - klasa która upraszcza dostęp do skomplikowanego systemu, z zewnątrz korzystamy z fasady zamiast z jego pojedynczych elementów
        Pyłek (obiektowy) - optymalizuje pamięć poprzez oddzielenie wspólnych ciężki danych od małych obiektów do których trafia referencja do części wspólnej.
                            wymaga tworzenia przez klasę fabryki która cashuje (np w mapie) wspólne części


    wzorce czynnościowe/operacyjne:
        Łańcuch zobowiązań/odpowiedzialności (obiektowy) - zapytanie przechodzi przez łańcuch serwisów z których każdy może wykonać swoją część pracy.
        Interpreter (klasowy) - rozumienie słów jako operacji do wykonania w programie (GIT, interpretery np. pythona, JS)
        Iterator (obiektowy) - przeglądanie obiektu element po elemencie. Fundament kolekcji (for each opiera się na interfejsie Iterable)
                                nie zmieniaj struktury zbioru który iterujesz!
        Mediator (obiektowy) - mediator ułatwia komunikacje między obiektami systemu wprowadzając jedną klasę przez którą
                                wszystkie inne zwracają się do siebie (zamiast bezpośrednio)
        Obserwator (obiektowy) - lista klientów którzy nasłuchują (Listener) na informację.
                                Obserwowany, wywołuje ich metode przekazując dane jako obiekt transportowy (DTO/record)
                                Luźna relacja między obserwowanym a obserwatorami (SOLID!)

        Strategia (obiektowy) - pozwala podmieniać działanie obiektu (algorytm) na podstawie jego stanu w trakcie działania programu
        Stan (obiektowy) - tak jak strategia ale zmiana stanu zmienia całkowicie zachowanie obiektu
        Metoda szablonowa (ang. template method) (klasowy) -
                                niezmienny schemat algorytmu przenosimy do abstrakcyjnej klasy, zmienne kroki nadpisujemy w klasach implementujących
        Pamiątka/Memento (ang. Memento) (obiektowy) - zapisuje wcześniejsze stany obiektu do których można przywracać obiekt.
                                                        Robi to z zachowaniem hermetyzacji
        Polecenie (obiektowy) - wywołanie metody zastępujemy całym osobnym obiektem polecenia. Dzięki czemu: separujemy od odbiorcy,
                                możemy archiwizować, kolejkować, cofać, odsuwać w czasie
        Odwiedzający/Wizytator (ang. visitor) (obiektowy) - mała ilość obiektów - dodajemy bardzo wiele operacji bez modyfikowania klas tych obiektów
                                umożliwia "double dispatch" - podwójne dziedziczenie. działanie wynika z miejsca obiektów w 2 różnych hierarchiach


